// Code generated by generator DO NOT EDIT.

package proxy

import (
	source "{{ .Relative }}/{{ .Name }}"
	zap "go.uber.org/zap"
{{- range .Imports }}
{{- if eq .Alias "" }}
	{{ .Source }}
{{- else }}
	{{ .Alias }} {{ .Source }}
{{- end }}
{{- end }}
)

{{- range .Interfaces }}
{{- $ifacename := .Name }}

// {{ $ifacename }}ProxyLogger proxy wrapper for source.{{ $ifacename }}.
type {{ $ifacename }}ProxyLogger struct {
	src source.{{ .Name }}
	log *zap.Logger
}

// New{{ .Name }}ProxyLogger creates a new proxy logger for source.{{ $ifacename }}.
func New{{ $ifacename }}ProxyLogger(
	src source.{{ $ifacename }},
	log *zap.Logger,
) *{{ $ifacename }}ProxyLogger {
	return &{{ $ifacename }}ProxyLogger{
		src: src,
		log: log.Named("{{ $ifacename }}ProxyLogger"),
	}
}

{{- range .Functions }}

{{- /* printing function body start */}}

// {{ .Name }} is logger proxy layer for source.{{ $ifacename }} struct.
func (p *{{ $ifacename }}ProxyLogger) {{ .Name }}(
{{- /* printing function input param in one line start */}}
{{- range $i, $p := .Input }}
	{{- if $i }}, {{ end }}{{ $p.Name}} {{ $p.Source }}
{{- end }})
{{- /* printing function input param in one line end */}}
{{- if eq (len .Output) 1 }} ({{ (index .Output 0).Name }} {{ (index .Output 0).Source }})
{{- else if gt (len .Output) 1 }} (
{{- /* printing function output param in one line start */}}
{{- range $i, $p := .Output }}
	{{- if $i }}, {{ end }}{{ $p.Name}} {{ $p.Source }}
{{- end }})
{{- /* printing function output param in one line end */}}
{{- else }}
{{- /* needed if output params is empty */}}
{{- end }} {
	p.log.Info(
		"{{ .Name }}() started",
	{{- range $i, $tag := .Tags }}
		 {{- if and (eq $tag.ProxyType 1) (eq $tag.TagType 1)}}
		zap.Any("{{ $tag.Alias}}", ctx.Value("{{ $tag.Key }}")),
		{{- end }}
		{{- if and (eq $tag.ProxyType 1) (eq $tag.TagType 2)}}
		zap.Any("{{ $tag.Alias}}", {{ $tag.Name }}.{{ $tag.Key }}),
		{{- end }}
	{{- end }}
	)


	{{- /* calling functions in proxy start */}}
	{{ if ge (len .Output) 1 }}
        {{- range $i, $p := .Output }}
            {{- if $i }}, {{ end }}{{ $p.Name }}
        {{- end }} = p.src.{{ .Name }}(
	{{- /* list of return more then zero and have no error */}}
    {{- /* list of return equal zero */}}
	{{- else }}p.src.{{ .Name }}(
    {{- end }}
	{{- /* calling functions in proxy end */}}

	{{- /* start make input params */}}
    {{- range $i, $p := .Input }}
        {{- if $i }}, {{ end }}{{ $p.Name }}
    {{- end }})
	{{- /* end make input params */}}

	{{- /* processed result of calling functions in proxy start */}}
	{{- if and (ge (len .Output) 1) (eq (index .Output (sub (len .Output) 1)).Source "error") }}
	if {{ (index .Output (sub (len .Output) 1)).Name }} != nil {
		p.log.Info(
			"{{ .Name }}() ends with error",
			zap.Error({{ (index .Output (sub (len .Output) 1)).Name }}),
		)
	} else {
		p.log.Info(
			"{{ .Name }}() ends with success",
		{{- range $i, $tag := .Tags }}
			{{- if and (eq $tag.ProxyType 1) (eq $tag.TagType 3)}}
			zap.Any("{{ $tag.Alias}}", {{ $tag.Name }}.{{ $tag.Key }}),
			{{- end }}
		{{- end }}
		)
	}
	{{- else }}
	p.log.Info("{{ .Name }}() ends with success")
	{{- end }}
	{{- /* processed result of calling functions in proxy end */}}

	return
}
{{- /* printing function body end */}}

{{- end }} {{- /* end cycle by functions */}}

{{- end }} {{- /* end cycle by interfaces */}}